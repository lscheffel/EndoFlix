<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EndoFlix - Video Player</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='favicon.ico') }}">
    <style>
        body { overflow: hidden; }
        .divider { width: 10px; background: #555; cursor: pointer; }
        .divider:hover { background: #777; }
        .playlist-frame { transition: width 0.3s; max-width: 20%; min-width: 20%; overflow-x: hidden; }
        .players-frame { transition: width 0.3s; }
        .video-container { position: relative; }
        .video-player { object-fit: contain; width: 100%; height: 100%; }
        .error-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); color: red; text-align: center; padding-top: 50px; display: none; }
        .compact-control { margin-bottom: 5px !important; padding: 2px !important; font-size: 0.9em; }
        .compact-btn { padding: 2px 5px !important; font-size: 0.9em; }
        .btn-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .btn-row button { flex: 1; margin: 0 2px; }
        .panic-btn { background-color: purple; padding: 5px !important; font-size: 1.2em; width: 100%; margin: 5px 0; }
        .shuffle-btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 5px; }
        .favorite-overlay { position: absolute; top: 10px; left: 10px; z-index: 10; cursor: pointer; }
        .share-overlay { position: absolute; top: 40px; left: 10px; z-index: 10; cursor: pointer; }
        .snapshot-overlay { position: absolute; top: 70px; left: 10px; z-index: 10; cursor: pointer; background: transparent; border: none; border-radius: 3px; padding: 1px; font-size: 18px; color: #fff; text-shadow: 0 0 3px black; }
        .burst-overlay { position: absolute; top: 100px; left: 10px; z-index: 10; cursor: pointer; background: transparent; border: none; border-radius: 3px; padding: 1px; font-size: 18px; color: #fff; text-shadow: 0 0 3px black; }
        .speed-overlay { position: absolute; top: 10px; right: 70px; z-index: 10; }
        .favorite-btn { cursor: pointer; margin-right: 5px; }
        .played-indicator { margin-left: 5px; }
        .spinner { 
            display: none; 
            border: 4px solid #f3f3f3; 
            border-top: 4px solid #3498db; 
            border-radius: 50%; 
            width: 30px; 
            height: 30px; 
            animation: spin 1s linear infinite; 
            margin: 5px auto; 
            transition: opacity 0.3s; 
        }
        .spinner-text { display: none; text-align: center; font-size: 0.8em; color: #f8f9fa; margin-top: 5px; }
        .theme-toggle { cursor: pointer; }
        .loop-overlay { position: absolute; top: 10px; right: 10px; z-index: 10; background: rgba(0,0,0,0.7); padding: 2px 5px; border-radius: 3px; font-size: 0.9em; color: #fff; }
        .dropdown-submenu {
            position: relative;
        }
        .dropdown-submenu .dropdown-menu {
            top: 0;
            left: 100%;
            margin-top: -1px;
            display: none;
        }
        .dropdown-submenu .dropdown-menu.show {
            display: block;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-dark text-light">
    <header class="p-2 bg-secondary d-flex justify-content-between">
        <h1 class="h5 m-0">EndoFlix - Video Player <span id="stats"></span></h1>
        <div>
<i class="bi bi-lightbulb theme-toggle me-2" id="themeToggle"></i>
            <a href="/keymaps" class="text-light me-2">Keymaps</a>
            <a href="/about" class="text-light me-2">Sobre</a>
            <a href="/ultra" class="text-light me-2">Ultra Mode</a>
            <a href="{{ url_for('auth.logout') }}" class="text-light">
                <i class="bi bi-box-arrow-right"></i> Logout
            </a>
        </div>
    </header>
    <div class="d-flex" style="height: calc(100vh - 50px);">
        <div class="players-frame" id="playersFrame" style="width: 80%;">
            <div class="row h-100 m-0" style="display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr;">
                <div class="p-1 video-container">
                    <video class="video-player" id="player1" controls preload="auto" loop>
                        <source id="source1" type="video/mp4">
                        <div class="error-overlay" id="error1">Erro ao carregar o vÃ­deo.</div>
                    </video>
                    <i class="favorite-overlay bi bi-star" id="favorite1"></i>
                    <i class="share-overlay bi bi-share" id="share1"></i>
                    <button class="snapshot-overlay" id="snapshot1">ðŸ“¸</button>
                    <button class="burst-overlay" id="burst1">ðŸ”„</button>
                    <select class="speed-overlay" id="speed1">
                        <option value="1" selected>1x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                        <option value="2.5">2.5x</option>
                        <option value="3">3x</option>
                        <option value="4">4x</option>
                    </select>
                    <div class="loop-overlay">
                        <input type="checkbox" id="loop1" checked>
                        <label for="loop1" style="margin-left: 5px;">Loop</label>
                    </div>
                </div>
                <div class="p-1 video-container">
                    <video class="video-player" id="player2" controls preload="auto" loop>
                        <source id="source2" type="video/mp4">
                        <div class="error-overlay" id="error2">Erro ao carregar o vÃ­deo.</div>
                    </video>
                    <i class="favorite-overlay bi bi-star" id="favorite2"></i>
                    <i class="share-overlay bi bi-share" id="share2"></i>
                    <button class="snapshot-overlay" id="snapshot2">ðŸ“¸</button>
                    <button class="burst-overlay" id="burst2">ðŸ”„</button>
                    <select class="speed-overlay" id="speed2">
                        <option value="1" selected>1x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                        <option value="2.5">2.5x</option>
                        <option value="3">3x</option>
                        <option value="4">4x</option>
                    </select>
                    <div class="loop-overlay">
                        <input type="checkbox" id="loop2" checked>
                        <label for="loop2" style="margin-left: 5px;">Loop</label>
                    </div>
                </div>
                <div class="p-1 video-container">
                    <video class="video-player" id="player3" controls preload="auto" loop>
                        <source id="source3" type="video/mp4">
                        <div class="error-overlay" id="error3">Erro ao carregar o vÃ­deo.</div>
                    </video>
                    <i class="favorite-overlay bi bi-star" id="favorite3"></i>
                    <i class="share-overlay bi bi-share" id="share3"></i>
                    <button class="snapshot-overlay" id="snapshot3">ðŸ“¸</button>
                    <button class="burst-overlay" id="burst3">ðŸ”„</button>
                    <select class="speed-overlay" id="speed3">
                        <option value="1" selected>1x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                        <option value="2.5">2.5x</option>
                        <option value="3">3x</option>
                        <option value="4">4x</option>
                    </select>
                    <div class="loop-overlay">
                        <input type="checkbox" id="loop3" checked>
                        <label for="loop3" style="margin-left: 5px;">Loop</label>
                    </div>
                </div>
                <div class="p-1 video-container">
                    <video class="video-player" id="player4" controls preload="auto" loop>
                        <source id="source4" type="video/mp4">
                        <div class="error-overlay" id="error4">Erro ao carregar o vÃ­deo.</div>
                    </video>
                    <i class="favorite-overlay bi bi-star" id="favorite4"></i>
                    <i class="share-overlay bi bi-share" id="share4"></i>
                    <button class="snapshot-overlay" id="snapshot4">ðŸ“¸</button>
                    <button class="burst-overlay" id="burst4">ðŸ”„</button>
                    <select class="speed-overlay" id="speed4">
                        <option value="1" selected>1x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                        <option value="2.5">2.5x</option>
                        <option value="3">3x</option>
                        <option value="4">4x</option>
                    </select>
                    <div class="loop-overlay">
                        <input type="checkbox" id="loop4" checked>
                        <label for="loop4" style="margin-left: 5px;">Loop</label>
                    </div>
                </div>
            </div>
        </div>
        <div class="divider" id="divider"></div>
        <div class="playlist-frame" id="playlistFrame" style="width: 20%;">
            <div class="p-2">
                <input type="text" id="folderInput" class="form-control compact-control" placeholder="Caminho da pasta (ex.: X:\Tiktok)">
                <div class="d-flex gap-2 mt-2">
                    <button onclick="scanFolder()" class="btn btn-primary compact-btn compact-control">Carregar Pasta</button>
                    <select id="burstInterval" class="form-select compact-control" style="width: auto; height: calc(1.5rem + 4px);">
                        <option value="100">0.1s</option>
                        <option value="200" selected>0.2s</option>
                        <option value="400">0.4s</option>
                        <option value="600">0.6s</option>
                        <option value="800">0.8s</option>
                        <option value="1000">1.0s</option>
                        <option value="1200">1.2s</option>
                        <option value="1400">1.4s</option>
                        <option value="1600">1.6s</option>
                        <option value="1800">1.8s</option>
                        <option value="2000">2.0s</option>
                    </select>
                    <select id="burstCount" class="form-select compact-control" style="width: auto; height: calc(1.5rem + 4px);">
                        <option value="2">2 shots</option>
                        <option value="3">3 shots</option>
                        <option value="4">4 shots</option>
                        <option value="5" selected>5 shots</option>
                        <option value="6">6 shots</option>
                        <option value="7">7 shots</option>
                        <option value="8">8 shots</option>
                        <option value="9">9 shots</option>
                        <option value="10">10 shots</option>
                        <option value="auto">Auto</option>
                    </select>
                    <button id="stopBurst" class="btn btn-danger compact-btn compact-control" style="display: none;">Stop</button>
                </div>
                <div id="loadingSpinner" class="spinner"></div>
                <div id="spinnerText" class="spinner-text">Processando...</div>
                <div class="dropdown">
                    <button class="btn btn-secondary dropdown-toggle form-select compact-control" type="button" id="playlistDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                        Selecionar Playlist
                    </button>
                    <ul class="dropdown-menu" aria-labelledby="playlistDropdown">
                        <li><a class="dropdown-item" href="#" onclick="loadSelectedPlaylist('favorites')">Favoritos</a></li>
                        <li class="dropdown-submenu">
                            <a class="dropdown-item" href="#" data-bs-toggle="dropdown" onclick="loadRecentPlaylist()">Recentes</a>
                            <ul class="dropdown-menu" id="recentPlaylistsMenu">
                            </ul>
                        </li>
                    </ul>
                </div>
                <div class="btn-row">
                    <button id="savePlaylist" class="btn btn-primary compact-btn">Save Playlist</button>
                    <button id="exportPlaylist" class="btn btn-secondary compact-btn">Export</button>
                    <button id="removePlaylist" class="btn btn-danger compact-btn">Remove Playlist</button>
                    <button id="updatePlaylist" class="btn btn-info compact-btn">Update Playlist</button>
                </div>
                <div class="btn-row">
                    <input type="file" id="importFile" class="form-control compact-control" accept=".json,.csv" style="flex: 1;">
                    <button id="importPlaylist" class="btn btn-success compact-btn">Import Playlist</button>
                </div>
                <select id="sessionSelect" class="form-select compact-control" onchange="loadSelectedSession()">
                    <option value="">Selecionar SessÃ£o</option>
                </select>
                <div class="btn-row">
                    <button id="saveSession" class="btn btn-primary compact-btn">Save Session</button>
                    <button id="removeSession" class="btn btn-danger compact-btn">Remove Session</button>
                </div>
                <input type="text" id="filterInput" class="form-control compact-control" placeholder="Filtrar por nome">
                <select id="extensionFilter" class="form-select compact-control" style="margin-top: 5px;">
                    <option value="">All Extensions</option>
                </select>
                <div class="d-flex gap-2" style="margin-top: 5px;">
                    <input type="number" id="sizeMin" placeholder="Min Size (MB)" class="form-control compact-control" style="width: 100px;">
                    <input type="number" id="sizeMax" placeholder="Max Size (MB)" class="form-control compact-control" style="width: 100px;">
                </div>
                <div class="d-flex gap-2" style="margin-top: 5px;">
                    <input type="date" id="dateFrom" class="form-control compact-control">
                    <input type="date" id="dateTo" class="form-control compact-control">
                </div>
                <select id="sortSelect" class="form-select compact-control">
                    <option value="name-asc">Name A-Z</option>
                    <option value="name-desc">Name Z-A</option>
                    <option value="date-asc">Date Asc</option>
                    <option value="date-desc">Date Desc</option>
                </select>
                <div class="btn-row">
                    <button id="batchFavorites" class="btn btn-warning compact-btn">Add/Remove Favorites</button>
                    <button id="batchRemovePlaylist" class="btn btn-danger compact-btn">Remove from Playlist</button>
                </div>
                <input type="text" id="searchInput" class="form-control compact-control" placeholder="Search videos">
                <button id="applyFiltersBtn" class="btn btn-primary compact-btn">Apply Filters</button>
                <ul id="fileList" class="list-group compact-control" style="max-height: 50vh; overflow-y: auto;"></ul>
                <div class="btn-row">
                    <button id="clearDeck" class="btn btn-warning compact-btn">Clear</button>
                </div>
                <div class="btn-row">
                    <button id="wishMeLuck" class="btn btn-success compact-btn">Shuffle</button>
                    <button id="randomSequence" class="btn btn-info compact-btn">Sequency</button>
                </div>
                <div class="btn-row">
                    <label>
                        <input type="checkbox" id="autoShuffleCheckbox" class="me-2"> Auto Shuffle
                    </label>
                    <input type="number" id="autoShuffleInterval" class="form-control compact-control" min="1" value="3" style="width: 60px;">
                </div>
                <div class="shuffle-btn-grid">
                    <button id="shuffle1" class="btn btn-success compact-btn">Shuffle 1</button>
                    <button id="shuffle2" class="btn btn-success compact-btn">Shuffle 2</button>
                    <button id="shuffle3" class="btn btn-success compact-btn">Shuffle 3</button>
                    <button id="shuffle4" class="btn btn-success compact-btn">Shuffle 4</button>
                </div>
                <div class="text-center">
                    <button id="panicBtn" class="btn panic-btn">PÃ¢nico</button>
                    <input type="text" id="panicUrls" class="form-control compact-control" placeholder="URLs de pÃ¢nico (separar por vÃ­rgula)">
                </div>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        const playersFrame = document.getElementById('playersFrame');
        const playlistFrame = document.getElementById('playlistFrame');
        const divider = document.getElementById('divider');
        const videoContainers = document.querySelectorAll('.video-container');
        let tempPlaylistName = null;
        let isPlaylistVisible = true;
        let currentFiles = [];
        let originalFiles = [];
        let playedVideos = new Set();
        let autoShuffleIntervalId = null;
        let favorites = [];
        let activePlayer = null;
        let recentPlaylists = JSON.parse(localStorage.getItem('recentPlaylists')) || [];

        function loadRecentPlaylist() {
            if (recentPlaylists.length > 0) {
                loadSelectedPlaylist(recentPlaylists[0]);
            } else {
                alert('Nenhuma playlist recente encontrada.');
            }
        }

        function showNotification(message, isError = false) {
            const notificationEl = document.createElement('div');
            notificationEl.textContent = message;
            notificationEl.style.position = 'fixed';
            notificationEl.style.top = '10px';
            notificationEl.style.right = '10px';
            notificationEl.style.background = isError ? 'rgba(255,0,0,0.8)' : 'rgba(0,0,0,0.8)';
            notificationEl.style.color = 'white';
            notificationEl.style.padding = '10px';
            notificationEl.style.borderRadius = '5px';
            notificationEl.style.zIndex = '1000';
            document.body.appendChild(notificationEl);
            setTimeout(() => notificationEl.remove(), 3000);
        }

        async function fetchStats() {
            try {
                const response = await fetch('/stats');
                const stats = await response.json();
                document.getElementById('stats').textContent = `(${stats.videos} vÃ­deos, ${stats.playlists} playlists, ${stats.sessions} sessÃµes)`;
            } catch (e) {
                console.error('Erro ao obter estatÃ­sticas:', e);
            }
        }

        function updatePlayerSizes() {
            const frameWidth = playersFrame.offsetWidth;
            const frameHeight = playersFrame.offsetHeight;
            const playerWidth = frameWidth / 2;
            const playerHeight = frameHeight / 2;

            videoContainers.forEach(container => {
                container.style.width = `${playerWidth}px`;
                container.style.height = `${playerHeight}px`;
                container.querySelector('.video-player').style.width = `${playerWidth}px`;
                container.querySelector('.video-player').style.height = `${playerHeight}px`;
            });
        }

        divider.addEventListener('click', () => {
            if (isPlaylistVisible) {
                playlistFrame.style.minWidth = '0';
                playlistFrame.style.maxWidth = '0';
                playlistFrame.style.width = '0';
                playersFrame.style.width = '100%';
                divider.style.background = '#777';
            } else {
                playlistFrame.style.minWidth = '20%';
                playlistFrame.style.maxWidth = '20%';
                playlistFrame.style.width = '20%';
                playersFrame.style.width = '80%';
                divider.style.background = '#555';
            }
            isPlaylistVisible = !isPlaylistVisible;
            setTimeout(updatePlayerSizes, 300);
        });

        window.addEventListener('resize', updatePlayerSizes);

        const themeToggle = document.getElementById('themeToggle');
        let isLightTheme = false;
        themeToggle.addEventListener('click', () => {
            isLightTheme = !isLightTheme;
            document.body.classList.toggle('bg-light', isLightTheme);
            document.body.classList.toggle('bg-dark', !isLightTheme);
            document.body.classList.toggle('text-dark', isLightTheme);
            document.body.classList.toggle('text-light', !isLightTheme);
            themeToggle.classList.toggle('bi-lightbulb', !isLightTheme);
            themeToggle.classList.toggle('bi-lightbulb-fill', isLightTheme);
        });

        async function scanFolder() {
    const folder = document.getElementById('folderInput').value.trim();
    if (!folder) return showNotification('Digite o caminho da pasta!', true);
    const spinner = document.getElementById('loadingSpinner');
    const spinnerText = document.getElementById('spinnerText');
    const fileList = document.getElementById('fileList');
    spinner.style.display = 'block';
    spinnerText.style.display = 'block';
    spinnerText.textContent = 'Iniciando escaneamento...';
    currentFiles = [];
    fileList.innerHTML = '';
    let tempPlaylistName = null;

    try {
        const response = await fetch('/scan', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ folder })
        });

        if (!response.ok) {
            throw new Error('Erro ao iniciar escaneamento');
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        async function readStream() {
            const { done, value } = await reader.read();
            if (done) {
                spinner.style.display = 'none';
                spinnerText.style.display = 'none';
                playedVideos.clear();
                loadSelectedPlaylist('');
                showNotification(`Escaneamento concluÃ­do: ${currentFiles.length} arquivos`, false);
                if (tempPlaylistName) {
                    document.getElementById('savePlaylistButton').style.display = 'block';
                }
                return;
            }

            const chunk = decoder.decode(value, { stream: true });
            for (const event of chunk.split('\n\n').filter(e => e)) {
                const data = JSON.parse(event.replace('data: ', ''));
                if (data.status === 'start') {
                    tempPlaylistName = data.temp_playlist;
                    spinnerText.textContent = `Processando 0/${data.total} arquivos`;
                } else if (data.status === 'update' || data.status === 'skipped') {
                    currentFiles.push(data.file);
                    await updateFileList(currentFiles);
                    if (data.progress && data.total) {
                        spinnerText.textContent = `Processando ${data.progress}/${data.total} arquivos`;
                    }
                } else if (data.status === 'error') {
                    showNotification(`Erro: ${data.message || data.file}`, true);
                } else if (data.status === 'end') {
                    spinner.style.display = 'none';
                    spinnerText.style.display = 'none';
                    await updateFileList(currentFiles);
                    playedVideos.clear();
                    loadSelectedPlaylist('');
                    showNotification(`Escaneamento concluÃ­do: ${currentFiles.length} arquivos`, false);
                    if (tempPlaylistName) {
                        document.getElementById('savePlaylistButton').style.display = 'block';
                    }
                }
            }
            return readStream();
        }

        await readStream();
    } catch (e) {
        spinner.style.display = 'none';
        spinnerText.style.display = 'none';
        showNotification(`Erro ao escanear: ${e.message}`, true);
    }
}

async function saveTempPlaylist() {
    if (!tempPlaylistName) {
        showNotification('Nenhuma playlist temporÃ¡ria disponÃ­vel!', true);
        return;
    }
    const newName = prompt('Nome da nova playlist:');
    if (!newName) return;
    try {
        const response = await fetch('/save_temp_playlist', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ temp_name: tempPlaylistName, new_name: newName })
        });
        const result = await response.json();
        if (result.success) {
            await loadPlaylists();
            loadSelectedPlaylist(newName);
            document.getElementById('savePlaylistButton').style.display = 'none';
            tempPlaylistName = null;
            showNotification(`Playlist "${newName}" salva`, false);
        } else {
            showNotification(`Erro ao salvar playlist: ${result.error}`, true);
        }
    } catch (e) {
        showNotification(`Erro ao salvar playlist: ${e.message}`, true);
    }
}

async function loadPlaylists() {
    try {
        const response = await fetch('/playlists');
        console.log('Response status:', response.status);
        if (!response.ok) {
            console.error('Fetch failed:', response.statusText);
            return;
        }
        const playlists = await response.json();
        console.log('Fetched playlists:', playlists);
        const menu = document.querySelector('.dropdown-menu');
        // Clear existing playlists (keep favorites and submenu)
        const items = menu.querySelectorAll('li:not(.dropdown-submenu):not(:first-child)');
        items.forEach(item => item.remove());
        // Add playlists
        for (const name in playlists) {
            console.log('Processing playlist:', name);
            if (!name.startsWith('temp_')) { // Excluir playlists temporÃ¡rias
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.className = 'dropdown-item';
                a.href = '#';
                a.textContent = name;
                a.onclick = () => loadSelectedPlaylist(name);
                li.appendChild(a);
                menu.appendChild(li);
                console.log('Added li for:', name);
            }
        }
        // Populate recent submenu
        const recentMenu = document.getElementById('recentPlaylistsMenu');
        recentMenu.innerHTML = '';
        recentPlaylists.forEach(name => {
            const li = document.createElement('li');
            const a = document.createElement('a');
            a.className = 'dropdown-item';
            a.href = '#';
            a.textContent = name;
            a.onclick = () => loadSelectedPlaylist(name);
            li.appendChild(a);
            recentMenu.appendChild(li);
        });
    } catch (e) {
        console.error('Erro ao carregar playlists:', e);
    }
}

        async function loadSessions() {
            try {
                const response = await fetch('/sessions');
                const sessions = await response.json();
                const select = document.getElementById('sessionSelect');
                select.innerHTML = '<option value="">Selecionar SessÃ£o</option>';
                for (const name in sessions) {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    select.appendChild(option);
                }
            } catch (e) {
                console.error('Erro ao carregar sessÃµes:', e);
            }
        }

        async function loadFavorites() {
            try {
                const response = await fetch('/favorites');
                favorites = await response.json(); // array of objects
                await updateFileList(currentFiles);
                updateFavoriteIcons();
            } catch (e) {
                console.error('Erro ao carregar favoritos:', e);
            }
        }

        async function toggleFavorite(file) {
            const isFavorite = favorites.some(f => f.path === file);
            try {
                const response = await fetch('/favorites', {
                    method: isFavorite ? 'DELETE' : 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ file_path: file })
                });
                const result = await response.json();
                if (result.success) {
                    if (isFavorite) {
                        favorites = favorites.filter(f => f.path !== file);
                        showNotification('Removido dos favoritos', false);
                    } else {
                        // Since we don't have metadata here, reload favorites
                        await loadFavorites();
                        showNotification('Adicionado aos favoritos', false);
                    }
                    await updateFileList(currentFiles);
                    updateFavoriteIcons();
                } else {
                    showNotification(`Erro ao gerenciar favorito: ${result.error}`, true);
                }
            } catch (e) {
                showNotification(`Erro ao gerenciar favorito: ${e.message}`, true);
            }
        }

        function updateFavoriteIcons() {
            videoContainers.forEach((container, index) => {
                const source = document.getElementById(`source${index + 1}`);
                const favoriteIcon = document.getElementById(`favorite${index + 1}`);
                if (source.src && source.src.includes('/video/')) {
                    const file = decodeURIComponent(source.src.split('/video/')[1]);
                    favoriteIcon.className = `favorite-overlay bi ${favorites.includes(file) ? 'bi-star-fill text-warning' : 'bi-star'}`;
                } else {
                    favoriteIcon.className = 'favorite-overlay bi bi-star';
                }
            });
        }

        async function loadSelectedPlaylist(name) {
            if (!name) {
                currentFiles = [];
                originalFiles = [];
                await updateFileList(currentFiles);
                document.getElementById('playlistDropdown').textContent = 'Selecionar Playlist';
                return;
            }
            try {
                if (name === 'favorites') {
                    currentFiles = favorites; // array of objects
                    playedVideos.clear();
                } else {
                    const response = await fetch('/playlists');
                    const playlists = await response.json();
                    currentFiles = playlists[name] ? playlists[name].files : []; // array of objects
                    playedVideos.clear();
                }
                originalFiles = [...currentFiles];
                applyFilters();
                // Update history
                if (name !== 'favorites') {
                    recentPlaylists = recentPlaylists.filter(p => p !== name);
                    recentPlaylists.unshift(name);
                    if (recentPlaylists.length > 5) recentPlaylists = recentPlaylists.slice(0, 5);
                    localStorage.setItem('recentPlaylists', JSON.stringify(recentPlaylists));
                }
                document.getElementById('playlistDropdown').textContent = name;
            } catch (e) {
                console.error('Erro ao carregar playlist:', e);
            }
        }

        async function loadSelectedSession() {
            const select = document.getElementById('sessionSelect');
            const name = select.value;
            if (!name) return;
            try {
                const response = await fetch('/sessions');
                const sessions = await response.json();
                const sessionVideos = sessions[name] || [];
                videoContainers.forEach((container, index) => {
                    const player = container.querySelector('.video-player');
                    const source = document.getElementById(`source${index + 1}`);
                    const errorOverlay = document.getElementById(`error${index + 1}`);
                    if (sessionVideos[index] && typeof sessionVideos[index] === 'string') {
                        source.src = `/video/${encodeURIComponent(sessionVideos[index])}`;
                        player.load();
                        player.play().catch(() => {
                            errorOverlay.style.display = 'block';
                            setTimeout(() => errorOverlay.style.display = 'none', 5000);
                        });
                    } else {
                        source.src = '';
                        player.load();
                    }
                });
                updateFavoriteIcons();
            } catch (e) {
                console.error('Erro ao carregar sessÃ£o:', e);
            }
        }

        document.getElementById('savePlaylist').addEventListener('click', async () => {
            const name = prompt('Digite o nome da playlist:');
            if (!name || name.trim() === '') return showNotification('O nome da playlist Ã© obrigatÃ³rio!', true);
            const files = Array.from(document.querySelectorAll('#fileList li')).map(li => li.dataset.path);
            const folder = document.getElementById('folderInput').value.trim();
            if (files.length === 0) return showNotification('Nenhum arquivo selecionado!', true);
            if (!folder) return showNotification('Digite o caminho da pasta para associar Ã  playlist!', true);
            try {
                const response = await fetch('/playlists', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: name.trim(), files, source_folder: folder })
                });
                const result = await response.json();
                if (result.success) {
                    showNotification('Playlist salva!', false);
                    await loadPlaylists();
                    await fetchStats();
                } else {
                    showNotification(`Erro ao salvar playlist: ${result.error}`, true);
                }
            } catch (e) {
                showNotification(`Erro ao salvar playlist: ${e.message}`, true);
            }
        });

        document.getElementById('exportPlaylist').addEventListener('click', async () => {
            const name = document.getElementById('playlistDropdown').textContent;
            if (!name || name === 'Selecionar Playlist' || name === 'favorites') return showNotification('Selecione uma playlist vÃ¡lida para exportar!', true);
            try {
                const response = await fetch(`/export_playlist/${encodeURIComponent(name)}`);
                if (!response.ok) throw new Error('Erro ao exportar playlist');
                const playlistData = await response.json();
                const blob = new Blob([JSON.stringify(playlistData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${name}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showNotification('Playlist exportada!', false);
            } catch (e) {
                showNotification(`Erro ao exportar playlist: ${e.message}`, true);
            }
        });

        document.getElementById('removePlaylist').addEventListener('click', async () => {
            const name = document.getElementById('playlistDropdown').textContent;
            if (!name || name === 'Selecionar Playlist' || name === 'favorites') return showNotification('Selecione uma playlist vÃ¡lida!', true);
            if (!confirm(`Deseja remover a playlist "${name}"?`)) return;
            try {
                const response = await fetch('/remove_playlist', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                const result = await response.json();
                if (result.success) {
                    showNotification('Playlist removida!', false);
                    loadSelectedPlaylist('');
                    currentFiles = [];
                    await updateFileList([]);
                    await loadPlaylists();
                    await fetchStats();
                } else {
                    showNotification(`Erro ao remover playlist: ${result.error}`, true);
                }
            } catch (e) {
                showNotification(`Erro ao remover playlist: ${e.message}`, true);
            }
        });

        document.getElementById('updatePlaylist').addEventListener('click', async () => {
    const name = document.getElementById('playlistDropdown').textContent;
    if (!name || name === 'Selecionar Playlist' || name === 'favorites') return showNotification('Selecione uma playlist vÃ¡lida!', true);
    if (!confirm(`Deseja atualizar a playlist "${name}" com base na pasta original?`)) return;
    const spinner = document.getElementById('loadingSpinner');
    const spinnerText = document.getElementById('spinnerText');
    spinner.style.display = 'block';
    spinnerText.style.display = 'block';
    spinnerText.textContent = 'Atualizando playlist...';
    try {
        // Obter source_folder da playlist
        const playlistResponse = await fetch('/playlists');
        const playlists = await playlistResponse.json();
        const playlist = playlists[name];
        if (!playlist || !playlist.source_folder) {
            throw new Error('Pasta da playlist nÃ£o encontrada');
        }
        const sourceFolder = playlist.source_folder;

        // Enviar atualizaÃ§Ã£o com temp_playlist, se disponÃ­vel
        const response = await fetch('/update_playlist', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                name,
                source_folder: sourceFolder,
                temp_playlist: tempPlaylistName || null
            })
        });
        const result = await response.json();
        if (result.success) {
            currentFiles = result.files.map(f => ({ path: f, duration: 0 }));
            originalFiles = [...currentFiles];
            applyFilters();
            await loadPlaylists();
            loadSelectedPlaylist(name);
            showNotification(`Playlist "${name}" atualizada com ${result.files.length} arquivos`, false);
        } else {
            showNotification(`Erro ao atualizar playlist: ${result.error}`, true);
        }
    } catch (e) {
        showNotification(`Erro ao atualizar playlist: ${e.message}`, true);
    } finally {
        spinner.style.display = 'none';
        spinnerText.style.display = 'none';
    }
});

       document.getElementById('importPlaylist').addEventListener('click', async () => {
           const fileInput = document.getElementById('importFile');
           const file = fileInput.files[0];
           if (!file) return showNotification('Selecione um arquivo para importar!', true);
           const formData = new FormData();
           formData.append('file', file);
           try {
               const response = await fetch('/import_playlist', {
                   method: 'POST',
                   body: formData
               });
               const result = await response.json();
               if (result.success) {
                   showNotification('Playlist importada com sucesso!', false);
                   await loadPlaylists();
                   await fetchStats();
               } else {
                   showNotification(`Erro ao importar playlist: ${result.error}`, true);
               }
           } catch (e) {
               showNotification(`Erro ao importar playlist: ${e.message}`, true);
           }
       });

       document.getElementById('saveSession').addEventListener('click', async () => {
            const videos = Array.from(videoContainers).map((container, index) => {
                const source = document.getElementById(`source${index + 1}`);
                return source.src ? decodeURIComponent(source.src.split('/video/')[1]) : null;
            }).filter(v => v);
            if (videos.length === 0) return showNotification('Nenhum vÃ­deo selecionado!', true);
            const playlistName = document.getElementById('playlistDropdown').textContent === 'Selecionar Playlist' ? 'Sem Playlist' : document.getElementById('playlistDropdown').textContent;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const name = `${timestamp}_${playlistName}`;
            try {
                const response = await fetch('/sessions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, videos })
                });
                const result = await response.json();
                if (result.success) {
                    showNotification('SessÃ£o salva!', false);
                    await loadSessions();
                    await fetchStats();
                } else {
                    showNotification(`Erro ao salvar sessÃ£o: ${result.error}`, true);
                }
            } catch (e) {
                showNotification(`Erro ao salvar sessÃ£o: ${e.message}`, true);
            }
        });

        document.getElementById('removeSession').addEventListener('click', async () => {
            const select = document.getElementById('sessionSelect');
            const name = select.value;
            if (!name) return showNotification('Selecione uma sessÃ£o!', true);
            if (!confirm(`Deseja remover a sessÃ£o "${name}"?`)) return;
            try {
                const response = await fetch('/remove_session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                const result = await response.json();
                if (result.success) {
                    showNotification('SessÃ£o removida!', false);
                    select.value = '';
                    await loadSessions();
                    await fetchStats();
                } else {
                    showNotification(`Erro ao remover sessÃ£o: ${result.error}`, true);
                }
            } catch (e) {
                showNotification(`Erro ao remover sessÃ£o: ${e.message}`, true);
            }
        });

        document.getElementById('clearDeck').addEventListener('click', () => {
            videoContainers.forEach((container, index) => {
                const player = container.querySelector('.video-player');
                const source = document.getElementById(`source${index + 1}`);
                source.src = '';
                player.load();
                player.pause();
            });
            updateFavoriteIcons();
        });

        document.getElementById('panicBtn').addEventListener('click', () => {
            let sites = ['https://www.google.com', 'https://www.youtube.com', 'https://www.wikipedia.org'];
            const customUrls = document.getElementById('panicUrls').value.trim();
            if (customUrls) {
                sites = customUrls.split(',').map(url => url.trim().startsWith('http') ? url : `https://${url}`);
                localStorage.setItem('panicUrls', customUrls);
            }
            const randomSite = sites[Math.floor(Math.random() * sites.length)];
            window.open(randomSite, '_blank');
            showNotification('BotÃ£o de pÃ¢nico acionado!', false);
        });

        document.getElementById('panicUrls').addEventListener('input', () => {
            localStorage.setItem('panicUrls', document.getElementById('panicUrls').value.trim());
        });

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function getUnplayedVideos(count) {
            let unplayed = currentFiles.filter(file => !playedVideos.has(file.path || file));
            if (unplayed.length < count) {
                playedVideos.clear();
                unplayed = [...currentFiles];
            }
            const shuffled = shuffleArray(unplayed);
            const selected = shuffled.slice(0, count);
            selected.forEach(file => playedVideos.add(file.path || file));
            return selected;
        }

        function shufflePlayer(playerIndex) {
            if (currentFiles.length === 0) return showNotification('Nenhum arquivo disponÃ­vel!', true);
            const selectedVideos = getUnplayedVideos(1);
            const randomFile = selectedVideos[0].path || selectedVideos[0];
            const container = videoContainers[playerIndex];
            const player = container.querySelector('.video-player');
            const source = document.getElementById(`source${playerIndex + 1}`);
            source.src = `/video/${encodeURIComponent(randomFile)}`;
            player.load();
            player.play().catch(() => {});
            updateFavoriteIcons();
            startAutoShuffle(`shuffle${playerIndex + 1}`);
        }

        document.getElementById('wishMeLuck').addEventListener('click', () => {
            if (currentFiles.length === 0) return showNotification('Nenhum arquivo disponÃ­vel!', true);
            const shuffled = getUnplayedVideos(4);
            videoContainers.forEach((container, index) => {
                if (shuffled[index]) {
                    const player = container.querySelector('.video-player');
                    const source = document.getElementById(`source${index + 1}`);
                    source.src = `/video/${encodeURIComponent(shuffled[index].path || shuffled[index])}`;
                    player.load();
                    player.play().catch(() => {});
                }
            });
            updateFavoriteIcons();
            startAutoShuffle('shuffle');
        });

        document.getElementById('randomSequence').addEventListener('click', () => {
            if (currentFiles.length < 4) return showNotification('Pelo menos 4 arquivos necessÃ¡rios!', true);
            const sortedFiles = [...currentFiles].sort((a, b) => (a.path || a).localeCompare(b.path || b));
            const randomIndex = Math.floor(Math.random() * (sortedFiles.length - 3));
            const sequence = sortedFiles.slice(randomIndex, randomIndex + 4);
            videoContainers.forEach((container, index) => {
                if (sequence[index]) {
                    const player = container.querySelector('.video-player');
                    const source = document.getElementById(`source${index + 1}`);
                    source.src = `/video/${encodeURIComponent(sequence[index].path || sequence[index])}`;
                    player.load();
                    player.play().catch(() => {});
                    playedVideos.add(sequence[index].path || sequence[index]);
                }
            });
            updateFavoriteIcons();
            startAutoShuffle('sequence');
        });

        document.getElementById('shuffle1').addEventListener('click', () => shufflePlayer(0));
        document.getElementById('shuffle2').addEventListener('click', () => shufflePlayer(1));
        document.getElementById('shuffle3').addEventListener('click', () => shufflePlayer(2));
        document.getElementById('shuffle4').addEventListener('click', () => shufflePlayer(3));

        function startAutoShuffle(mode) {
            const autoShuffleCheckbox = document.getElementById('autoShuffleCheckbox');
            const intervalInput = document.getElementById('autoShuffleInterval');
            if (autoShuffleCheckbox.checked) {
                if (autoShuffleIntervalId) clearInterval(autoShuffleIntervalId);
                const interval = parseInt(intervalInput.value) * 1000 || 3000;
                autoShuffleIntervalId = setInterval(() => {
                    if (mode === 'shuffle') document.getElementById('wishMeLuck').click();
                    else if (mode === 'sequence') document.getElementById('randomSequence').click();
                    else if (mode.startsWith('shuffle')) shufflePlayer(parseInt(mode.replace('shuffle', '')) - 1);
                }, interval);
            }
        }

        document.getElementById('autoShuffleCheckbox').addEventListener('change', e => {
            if (!e.target.checked && autoShuffleIntervalId) {
                clearInterval(autoShuffleIntervalId);
                autoShuffleIntervalId = null;
            }
        });

        document.getElementById('autoShuffleInterval').addEventListener('input', () => {
            if (autoShuffleIntervalId) {
                clearInterval(autoShuffleIntervalId);
                const mode = document.activeElement.id === 'wishMeLuck' ? 'shuffle' : 
                             document.activeElement.id === 'randomSequence' ? 'sequence' : 
                             document.activeElement.id.startsWith('shuffle') ? document.activeElement.id : 'shuffle';
                startAutoShuffle(mode);
            }
        });

        function applyFilters() {
            const nameFilter = document.getElementById('filterInput').value.toLowerCase();
            const search = document.getElementById('searchInput').value.toLowerCase();
            const extensionFilter = document.getElementById('extensionFilter').value;
            const sizeMin = parseFloat(document.getElementById('sizeMin').value) || 0;
            const sizeMax = parseFloat(document.getElementById('sizeMax').value) || Infinity;
            const dateFrom = document.getElementById('dateFrom').value ? new Date(document.getElementById('dateFrom').value) : null;
            const dateTo = document.getElementById('dateTo').value ? new Date(document.getElementById('dateTo').value) : null;
            const sortValue = document.getElementById('sortSelect').value;

            let filtered = originalFiles.filter(file => {
                const path = file.path || file;
                const name = path.split(/[\\/]/).pop().toLowerCase();
                const ext = file.extension || path.split('.').pop().toLowerCase();
                const size = (file.size || 0) / (1024*1024); // MB
                const modified = file.modified ? new Date(file.modified) : null;
                return name.includes(nameFilter) &&
                       name.includes(search) &&
                       (!extensionFilter || ext === extensionFilter) &&
                       size >= sizeMin && size <= sizeMax &&
                       (!dateFrom || (modified && modified >= dateFrom)) &&
                       (!dateTo || (modified && modified <= dateTo));
            });

            // Apply sorting
            const [field, order] = sortValue.split('-');
            if (field === 'name') {
                filtered.sort((a, b) => {
                    const nameA = (a.path || a).split(/[\\/]/).pop().toLowerCase();
                    const nameB = (b.path || b).split(/[\\/]/).pop().toLowerCase();
                    return order === 'asc' ? nameA.localeCompare(nameB) : nameB.localeCompare(nameA);
                });
            } else if (field === 'date') {
                filtered.sort((a, b) => {
                    const dateA = a.modified ? new Date(a.modified) : new Date(0);
                    const dateB = b.modified ? new Date(b.modified) : new Date(0);
                    return order === 'asc' ? dateA - dateB : dateB - dateA;
                });
            }

            currentFiles = filtered;
            updateFileList(filtered);
        }

        document.getElementById('applyFiltersBtn').addEventListener('click', applyFilters);

        document.getElementById('sortSelect').addEventListener('change', applyFilters);

        async function fetchVideoFile(filePath) {
            try {
                const response = await fetch(`/video/${encodeURIComponent(filePath)}`);
                const blob = await response.blob();
                const fileName = filePath.split(/[\\/]/).pop();
                return new File([blob], fileName, { type: blob.type });
            } catch (e) {
                console.error('Erro ao buscar vÃ­deo:', e);
                return null;
            }
        }


        async function updateFileList(files) {
            const list = document.getElementById('fileList');
            list.innerHTML = '';
            if (files && files.length > 0) {
                files.forEach((file, index) => {
                    const path = file.path || file;
                    const li = document.createElement('li');
                    li.className = 'list-group-item draggable d-flex align-items-center';
                    li.draggable = true;
                    li.dataset.path = path;
                    li.dataset.size = file.size || 0;
                    li.dataset.modified = file.modified || '';
                    li.dataset.extension = file.extension || path.split('.').pop().toLowerCase();
                    const isFavorite = favorites.some(f => f.path === path);
                    li.innerHTML = `
                        <input type="checkbox" class="file-checkbox me-2" data-path="${path}">
                        <i class="${isFavorite ? 'bi-star-fill text-warning' : 'bi-star'} favorite-btn"></i>
                        <span>${path.split(/[\\/]/).pop()}</span>
                        ${playedVideos.has(path) ? '<i class="bi bi-check-circle played-indicator text-success"></i>' : ''}
                    `;
                    li.querySelector('.favorite-btn').addEventListener('click', () => toggleFavorite(path));
                    li.addEventListener('dragstart', e => e.dataTransfer.setData('text/plain', path));
                    list.appendChild(li);
                });
                // Populate extension filter
                const extensions = new Set();
                files.forEach(file => {
                    const ext = (file.extension || (file.path || file).split('.').pop().toLowerCase());
                    extensions.add(ext);
                });
                const select = document.getElementById('extensionFilter');
                select.innerHTML = '<option value="">All Extensions</option>';
                extensions.forEach(ext => {
                    const option = document.createElement('option');
                    option.value = ext;
                    option.textContent = ext.toUpperCase();
                    select.appendChild(option);
                });
            } else {
                const li = document.createElement('li');
                li.className = 'list-group-item';
                li.textContent = 'Nenhum arquivo encontrado';
                list.appendChild(li);
            }
        }

        videoContainers.forEach((container, index) => {
            const player = container.querySelector('.video-player');
            const source = document.getElementById(`source${index + 1}`);
            const errorOverlay = document.getElementById(`error${index + 1}`);
            const favoriteIcon = document.getElementById(`favorite${index + 1}`);
            const shareIcon = document.getElementById(`share${index + 1}`);
            const speedSelect = document.getElementById(`speed${index + 1}`);

            player.parentElement.addEventListener('drop', e => {
                e.preventDefault();
                const file = e.dataTransfer.getData('text/plain');
                const videoUrl = `/video/${encodeURIComponent(file)}`;
                if (player.src !== videoUrl) {
                    source.src = videoUrl;
                    player.load();
                    player.onloadeddata = () => player.play().catch(() => {
                        errorOverlay.style.display = 'block';
                        setTimeout(() => errorOverlay.style.display = 'none', 5000);
                    });
                    playedVideos.add(file);
                    updateFileList(currentFiles);
                    updateFavoriteIcons();
                }
            });

            player.parentElement.addEventListener('dragover', e => e.preventDefault());

            player.addEventListener('click', () => activePlayer = player);

            player.addEventListener('dblclick', () => {
                if (player.requestFullscreen) player.requestFullscreen();
                else if (player.webkitRequestFullscreen) player.webkitRequestFullscreen();
                else if (player.msRequestFullscreen) player.msRequestFullscreen();
            });

            favoriteIcon.addEventListener('click', () => {
                if (source.src && source.src.includes('/video/')) {
                    toggleFavorite(decodeURIComponent(source.src.split('/video/')[1]));
                } else {
                    showNotification(`Nenhum vÃ­deo no player ${index + 1}!`, true);
                }
            });

            shareIcon.addEventListener('click', async () => {
                if (source.src && source.src.includes('/video/')) {
                    const filePath = decodeURIComponent(source.src.split('/video/')[1]);
                    const fileName = filePath.split(/[\\/]/).pop();
                    try {
                        if (navigator.share && navigator.canShare && navigator.canShare({ files: [] })) {
                            const file = await fetchVideoFile(filePath);
                            if (file) {
                                await navigator.share({
                                    title: `EndoFlix Video: ${fileName}`,
                                    files: [file],
                                    text: `VÃ­deo: ${filePath}`
                                });
                            } else {
                                await navigator.share({
                                    title: `EndoFlix Video: ${fileName}`,
                                    text: `VÃ­deo: ${filePath}`
                                });
                            }
                        } else {
                            navigator.clipboard.writeText(filePath).then(() => showNotification('Caminho copiado!', false));
                        }
                    } catch (e) {
                        showNotification(`Erro ao compartilhar: ${e.message}`, true);
                    }
                } else {
                    showNotification(`Nenhum vÃ­deo no player ${index + 1}!`, true);
                }
            });

            speedSelect.addEventListener('change', () => {
                player.playbackRate = parseFloat(speedSelect.value);
            });

            const loopCheckbox = document.getElementById(`loop${index + 1}`);
            loopCheckbox.addEventListener('change', () => {
                player.loop = loopCheckbox.checked;
            });

            player.addEventListener('ended', () => {
                if (!player.loop) {
                    shufflePlayer(index);
                }
            });
        });

        // Batch operations
        function getSelectedFiles() {
            const checkboxes = document.querySelectorAll('#fileList .file-checkbox:checked');
            return Array.from(checkboxes).map(cb => cb.dataset.path);
        }

        async function batchToggleFavorites() {
            const selectedFiles = getSelectedFiles();
            if (selectedFiles.length === 0) {
                showNotification('Nenhum arquivo selecionado!', true);
                return;
            }
            // For simplicity, assume toggle: if any is favorite, remove all, else add all
            const anyFavorite = selectedFiles.some(f => favorites.includes(f));
            try {
                const response = await fetch('/favorites', {
                    method: anyFavorite ? 'DELETE' : 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ file_paths: selectedFiles })
                });
                const result = await response.json();
                if (result.success) {
                    if (anyFavorite) {
                        favorites = favorites.filter(f => !selectedFiles.includes(f));
                        showNotification('Removidos dos favoritos', false);
                    } else {
                        favorites.push(...selectedFiles);
                        showNotification('Adicionados aos favoritos', false);
                    }
                    await updateFileList(currentFiles);
                    updateFavoriteIcons();
                } else {
                    showNotification(`Erro: ${result.error}`, true);
                }
            } catch (e) {
                showNotification(`Erro: ${e.message}`, true);
            }
        }

        async function batchRemoveFromPlaylist() {
            const selectedFiles = getSelectedFiles();
            if (selectedFiles.length === 0) {
                showNotification('Nenhum arquivo selecionado!', true);
                return;
            }
            const playlistName = document.getElementById('playlistDropdown').textContent;
            if (!playlistName || playlistName === 'Selecionar Playlist' || playlistName === 'favorites') {
                showNotification('Selecione uma playlist vÃ¡lida!', true);
                return;
            }
            try {
                const response = await fetch('/remove_from_playlist', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: playlistName, files: selectedFiles })
                });
                const result = await response.json();
                if (result.success) {
                    currentFiles = currentFiles.filter(f => !selectedFiles.includes(f.path || f));
                    originalFiles = [...currentFiles];
                    applyFilters();
                    showNotification('Arquivos removidos da playlist', false);
                } else {
                    showNotification(`Erro: ${result.error}`, true);
                }
            } catch (e) {
                showNotification(`Erro: ${e.message}`, true);
            }
        }

        document.getElementById('batchFavorites').addEventListener('click', batchToggleFavorites);
        document.getElementById('batchRemovePlaylist').addEventListener('click', batchRemoveFromPlaylist);

        // Submenu toggle
        document.querySelectorAll('.dropdown-submenu a').forEach(item => {
            item.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                const submenu = this.nextElementSibling;
                submenu.classList.toggle('show');
            });
        });

        loadPlaylists();
        loadSessions();
        loadFavorites();
        fetchStats();
        updatePlayerSizes();

        // FunÃ§Ã£o para criar snapshot
        async function createSnapshot(video) {
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            const source = video.parentElement.querySelector('source');
            if (!source.src) {
                showNotification('Nenhum vÃ­deo carregado!', true);
                return;
            }

            try {
                const imageData = canvas.toDataURL('image/webp', 0.9);
                const videoPath = decodeURIComponent(source.src.split('/video/')[1]);
                
                const response = await fetch('/save_snapshot', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        video_path: videoPath,
                        image_data: imageData,
                        is_burst: false
                    })
                });

                const result = await response.json();
                if (result.success) {
                    showNotification('Snapshot salvo com sucesso!', false);
                } else {
                    showNotification(`Erro ao salvar snapshot: ${result.error}`, true);
                }
            } catch (e) {
                showNotification(`Erro ao salvar snapshot: ${e.message}`, true);
            }
        }

        // FunÃ§Ã£o para criar burst
        async function createBurst(video) {
            const source = video.parentElement.querySelector('source');
            if (!source.src) {
                showNotification('Nenhum vÃ­deo carregado!', true);
                return;
            }

            const videoPath = decodeURIComponent(source.src.split('/video/')[1]);
            const burstCountSelect = document.getElementById('burstCount');
            const stopBurstBtn = document.getElementById('stopBurst');
            let isAutoMode = burstCountSelect.value === 'auto';
            let burstCount = isAutoMode ? 999 : parseInt(burstCountSelect.value);
            const intervalMs = parseInt(document.getElementById('burstInterval').value);
            let shouldStop = false;

            stopBurstBtn.style.display = 'block';
            stopBurstBtn.onclick = () => {
                shouldStop = true;
                stopBurstBtn.style.display = 'none';
            };

            // Captura todos os frames primeiro
            const frames = [];
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');

            for (let i = 0; i < burstCount && !shouldStop; i++) {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                frames.push(canvas.toDataURL('image/webp', 0.9));
                await new Promise(resolve => setTimeout(resolve, intervalMs));
            }

            if (shouldStop) {
                stopBurstBtn.style.display = 'none';
                return;
            }

            // Envia todos os frames em lote
            try {
                const response = await fetch('/save_snapshot', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        video_path: videoPath,
                        frames: frames,
                        is_burst: true
                    })
                });

                const result = await response.json();
                if (result.success) {
                    showNotification(`Burst completo! ${frames.length} imagens salvas com sucesso.`, false);
                } else {
                    showNotification(`Erro ao salvar burst: ${result.error}`, true);
                }
            } catch (e) {
                showNotification(`Erro ao salvar burst: ${e.message}`, true);
            }

            stopBurstBtn.style.display = 'none';
        }

        // Adicionar event listeners para os botÃµes de snapshot e burst
        for (let i = 1; i <= 4; i++) {
            const snapshotBtn = document.getElementById(`snapshot${i}`);
            const burstBtn = document.getElementById(`burst${i}`);
            const video = document.getElementById(`player${i}`);

            snapshotBtn.addEventListener('click', () => createSnapshot(video));
            burstBtn.addEventListener('click', () => createBurst(video));
        }
    </script>
    <script src="/static/keymap.js"></script>
</body>
</html>